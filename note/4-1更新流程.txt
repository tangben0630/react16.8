react

  把整个的更新流程,拆成一个个fiber对象,并且可控,可以记录更新到哪里,可以中断,
  之前是不可以中断的,

  三种情况会创建更新:

    setState

    ReactDom.render

    forceUpdate

    上面三种会触发更新   createUpdate   

                                              一个应用可能多个root
    1, createUpdate ====>> scheduleWork ====>> addRootToScheduler ===>> 

    2, 如果正在render阶段,或者前后root不同 ====>> requestWork ====>> 

    3, 如果是expiration Time sync 会执行 ====>> performSyncWork ===>> 不是sync 执行 scheduleCallbackWith

    4, schedule流程:

        async schedule work: 利用的是requestidlecallback,能让浏览器优先进行他更新的任务
                              在每一帧有多余时间的时候,来调用react设置的callback,然后执行react的更新
                              react会自己计时,在这个时间内,可以更新,在这个时间内,如果没有执行完
                              react会把执行权交换给浏览器,让浏览器执行自己的事情

                              react通过 requestAnimationFrame + 浏览器队列来实现,模拟 requestidlecallback

            最终调用的是 performAsyncWork === 这里就是进入了 react的更新流程
            react会遍历每一棵树的每一个单元进行更新操作, 通过 deadline 判断一下是否还有
            js运行的时间片,每一个performAsyncWork是有一个时间限制的,默认 22ms,

            对于同步任务,直接遍历树,完成更新

    5, perform Work with deadline 
        这种情况,直接调用 performWorkOnRoot,如果有 deadline,会判断deadline是否过期,
        如果过期会回头继续进行异步的回调,
        addRootToScheduler 在维护队列的更新
        每次更新都会只更新一个当前优先级最高的任务
        deadline可以帮忙跳出循环

        低优先级的react的更新,不会阻塞浏览器的主体的更新



第二次更新流程:

  setstate foucreupdate  Dom.render  都会产生更新
    createUpdate ===>> 进入 scheduleWork ====> addRootToScheduler(在一个react中,
    可能不止一个root节点, dom.render就会创建一个,调用多次,就会创建多个root节点,多个root纯在,需要维护)
    ====>> requestWork (这里判断expirationTime 是不是异步,给出两种更新模式,两种情况,同步的时候,
    performSyncWork,异步表示优先级不是很高:scheduleCallbackWith这里判断expirationTime) ===>>



    整个异步的调度流程: schedule

      大体是利用requestidlecallback能够优先更新浏览器自己的任务,在每一帧有空闲的时候,调用react设置的callback,react自己会计时
      在这个时间内,react可以执行自己的work,如果这个时间内没有执行完,react需要把js的执行权,交还给浏览器,

      通过 requestAnimationFrame+js队列

      最终调用的是performAsyncWork, react会传给他一个 deadline, 通过deadline判断,当前任务是否还有js运行时间片(默认22ms)

      判断expirationTime有没有超时,

      找到 最终调用的performAsyncWork以后, 对一个节点进行更新,


  整个异步的调度流程(2): schedule

    1, 大体是利用requestidlecallback能够优先更新浏览器自己的任务,在每一帧有空闲的时候,调用react设置的callback,react自己会计时
        在这个时间内,react可以执行自己的work,如果这个时间内没有执行完,react需要把js的执行权,交还给浏览器,

    2, 调用scheduleDeieneCallback  有个callbackList 这里的任务 有个 expirationTime , 判断他是否超时

    3, 调用的是performAsyncWork , react会传给他一个 deadline , 遍历每个单元 更新
        通过deadline判断,当前任务是否还有js运行时间片(默认22ms), 如果超时 

    4, deadline 跳出后 直接回到原来 把js 执行权 交给浏览器

