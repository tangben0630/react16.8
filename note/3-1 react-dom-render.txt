

1, 创建更新的方式  三种

  ReactDom.render

  setState

  forceUpdate


  创建 ReactRoot , 
        FiberRoot , 
        RootFiber



  1, 传入容器   挂载点  return new ReactRoot(container, isConcurrent, shouldHydrate);

  2, const root = DOMRenderer.createContainer(container, isConcurrent, hydrate);创建了一个节点

  3, return createFiberRoot(containerInfo, isConcurrent, hydrate);

  4, 最后 return FiberRoot

    root = ({
      //对面root节点的一个fiber对象
      current: uninitializedFiber,
      //dom节点
      containerInfo: containerInfo,
      //
      pendingChildren: null,

      //下面的几个time，就是时间调度的几个时间
      earliestPendingTime: NoWork,
      latestPendingTime: NoWork,
      earliestSuspendedTime: NoWork,
      latestSuspendedTime: NoWork,
      latestPingedTime: NoWork,

      //标记整个渲染过程中是不是有错误
      didError: false,
      //
      pendingCommitExpirationTime: NoWork,
      //在一次渲染过程中，已经完成了的那个渲染任务（当前优先级最高的那个任务 并且已经完成的）
      finishedWork: null,
      //记录一个超时的情况
      timeoutHandle: noTimeout,
      //只有主动调动一个api时候才有
      context: null,
      //
      pendingContext: null,
      //是不是需要合并dom
      hydrate,
      //需要执行那个优先级的任务
      nextExpirationTimeToWorkOn: NoWork,
      //调度过程中
      expirationTime: NoWork,
      //
      firstBatch: null,
      //单向链表的一个属性
      nextScheduledRoot: null,
      //
      interactionThreadID: unstable_getThreadID(),
      //
      memoizedInteractions: new Set(),
      //
      pendingInteractionMap: new Map(),

    FiberRoot: 整个应用的起点

                包含应用挂载的目标节点

                记录整个应用更新过程的各种信息

 5, unbatchedUpdates ===>> root.render() ==>> updateContainer() 计算出了一个expirationTime

 6, updateContainerAtExpirationTime 调用 ===> scheduleRootUpdate() return  expirationTime

    updateContainerAtExpirationTime ===> scheduleWork 开始调度



    创建更新的过程